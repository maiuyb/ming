# Project08-Eval与Atom
## 要求
在本次作业，你需要完成两个新部分，一是用于执行动态代码的`eval`和`read-string`函数，二是新加入的`LAtom`对象及与其相关的函数。

我们测试用例保证输入的程序都是合法的，**没有词法、语法或语义错误**。

## 代码与数据同构
可以注意到，Lisp中代码和代码执行的结果即数据都以`LObject`的形式出现，所以代码和数据并没有实质上的区别。

理所当然地，我们可以想到，是否可以像计算数据一样，让程序在运行时动态地构建代码并且执行呢？当然可以，实际上这正是Lisp的一个重要特性——宏的实质。

在这一次作业中，我们暂时不实现宏，而是实现更底层的两个函数，`eval`和`read-string`。具体来说：

1. `eval`函数接受一个参数`P`，将`P`直接作为程序在全局量环境下执行，并返回执行结果。如`(eval (cons + (cons 1 (cons 2 nil))))`得到`LInteger(3)`
2. `read-string`函数接受一个`LString`参数`code`，将`code`的内容解析为`LObject`并返回。如`(read-string "(+ 1 2)")`返回`LList(LSymbol("+"), LInteger(1), LInteger(2))`

## 不可变性与Atom
到目前为止，我们引入的数据对象都是不可变的，也就是说一个对象在被创建之后，其中的内容就不会再改变。这样做有许多好处，比如我们可以简单地对内容相同的值使用同一个对象（如`nil`），但有时也会带来不便。

本次作业中，我们引入了一类具有可变性的`LAtom`对象，`LAtom`对象可变地持有对其他对象的引用。具体来说，我们加入以下函数对其进行操作：

1. `atom`函数接受一个参数`o`，返回一个新的`LAtom`对象，其持有对`o`的引用
2. `atom?`函数接受一个参数`o`，判断`o`是否是一个`LAtom`对象，是则返回`LInteger(1)`，否则返回`LInteger(0)`
3. `deref`函数接受一个`LAtom`参数`atom`，返回`atom`当前引用的对象
4. `reset!`函数接受一个`LAtom`参数`atom`与一个参数`o`，将`atom`所持有的引用改为对`o`的引用，并返回`o`
5. `swap!`函数接受一个`LAtom`参数`atom`，一个函数`func`和若干额外参数`extras`，然后使用`atom`当前引用的对象作为第一个参数，`extras`作为剩下的参数调用`func`得到返回值`ret`，将`atom`所持有的引用改为对`ret`的引用，并返回`ret`

如：`(let* ((x (atom 1))) (do (swap! x + 1) (deref x)))`执行得到`LInteger(2)`